## 01 - 세 자리 수 중 최솟값 찾기

- Math.min을 사용할 때에 ...args와 같은 rest 문법으로 파라미터를 받았다면, spread 문법으로 뿌려주어야 한다.

## 02 - 삼각형 판별하기

- 삼각형의 조건 : 주어진 길이들을 아무곳이나 배치할 수 있다고 했을 때, 최대값이 나머지 두 변의 길이의 합보다 크면 안된다.
- Technic : 두 변에 무엇이 올지는 모르지만, 두 변의 합(sum) 이라는 조건이 주어져 있기 때문에 모든 변들의 합을 구한 후, 최대값을 구해서 최대값을 빼주면 두변의 합을 구할 수 있다.

## 03 - 연필 개수

- Built-In Object, Math를 사용할 수 있는지에 대한 문제였는듯

## 04 - 1부터 N까지 합 출력

- for문을 사용한 단순연산과, 배열을 만들어 reduce를 사용하여 연산하는 것 중에 어느 것이 빠를까?

```jsx
// case 1
console.log(answer1(10000)); // 9.942ms
console.log(answer2(10000)); // 1.711ms

// case 2
console.log(answer1(1000000)); // 6.291ms
console.log(answer2(1000000)); // 122.785ms
```

- array를 사용하게 되면, 메모리를 차지하는 배열이 생기기 때문에 어느정도 수용가능한 낮은 크기의 배열에서는 reduce 방식이 빠르게 동작했지만, 큰 크기를 나타낼 수 있는 배열에서는 일반 for문 연산보다 속도가 느린 것으로 나타났다. 합을 이용한 코딩테스트에서는 숫자의 범위가 낮게 설정되어 있다면 reduce를 되도록 사용하는 것도 좋은 방법인 것 같다.

## 05 - 최솟값 구하기

- 내장함수를 사용할 수 있다는 조건이면, 주저없이 Math.min을 쓰겠지만, Number.MAX_SAFE_INTEGER 라는 최대값을 min에 박아두고 하는 방식도 있다.
- 위에서 스프레드 문법으로 넘기기를 언급했는데, apply(null, arr) 문법으로도 해결할 수 있다. 이는 Function.prototype인 this binding을 위한 call과 apply의 차이때문이다.

```jsx
Function.prototype.call(context, arg1, arg2, ...);
Function.prototype.apply(context, [arg1, arg2, ...]);
```

- call 함수와 보통 함수는 인자를 쉼표로 구분하지만, apply는 배열의 아이템으로 인자를 구분하기 때문에 위 문제를 해결할 수 있다.

## 06 - 홀수

- Math.min.apply(null, arr) 활용 완료!
- Python을 너무 쓰다보니 np.where 해버렸다,, JS에서는 HOF, filter!!

## 07 - 10부제

- So Easy,,,

## 08 - 일곱 난쟁이

- 9개의 배열에서 7개의 경우에 수의 합이 100을 만족하는 경우를 찾는 과정이다. 이럴 경우에는 9개의 전체 합을 구한 후, 2개의 조합씩 차를 구하여 어떤 수가 제거되었을 때, 배열의 합이 100을 만족하는지 찾으면 된다.
- splice는 인덱스로부터 개수, slice는 start & end 매개변수로, 둘 다 리턴값은 잘라진 배열

## 09 - A를 #으로

- String의 replace 함수는 첫 번째 문자열 밖에는 변경되지 않는다.
- 정규식 g는 발생할 모든 pattern에 대한 전역 검색 을 뜻한다.

## 10 - 문자찾기

- 대박;; split을 쓰면 문자를 분할할 수 있는데, 분할된 개수에서 1을 빼면 매개변수로 보낸 값이 n개 존재한다는 것을 의미한다.

## 11 - 대문자 찾기

- 대문자는 아스키코드에서 65 ~ 90에, 소문자는 97 ~ 122에 위치해있다.

## 12 - 대문자 통일

- 위에서 아스키코드 배워서 이용해봤음
